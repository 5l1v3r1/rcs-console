<?xml version="1.0" encoding="utf-8"?>

<s:VGroup xmlns:fx="http://ns.adobe.com/mxml/2009"
					xmlns:s="library://ns.adobe.com/flex/spark"
					xmlns:mx="library://ns.adobe.com/flex/mx"
					xmlns:maps="com.google.maps.*"
					xmlns:components="it.ht.rcs.console.entities.view.components.*"
					xmlns:timeline="it.ht.rcs.console.entities.view.components.advanced.timeline.*"
					xmlns:ravis="org.un.cava.birdeye.ravis.graphLayout.visual.*"
					xmlns:entities="it.ht.rcs.console.entities.view.*"
					height="100%"
					width="100%" hide="onRemovedFromStage()"
					
					addedToStage="onAddedToStage()" removedFromStage="onRemovedFromStage()">
	<fx:Script>
		<![CDATA[
      import com.google.maps.LatLng;
      import com.google.maps.LatLngBounds;
      import com.google.maps.Map;
      import com.google.maps.MapEvent;
      import com.google.maps.MapMouseEvent;
      import com.google.maps.MapType;
      import com.google.maps.PaneId;
      import com.google.maps.controls.MapTypeControl;
      import com.google.maps.controls.PositionControl;
      import com.google.maps.controls.ZoomControl;
      import com.google.maps.interfaces.IOverlay;
      import com.google.maps.interfaces.IPane;
      import com.google.maps.overlays.GroundOverlay;
      import com.google.maps.overlays.GroundOverlayOptions;
      import com.google.maps.overlays.Marker;
      import com.google.maps.overlays.MarkerOptions;
      import com.google.maps.overlays.Polyline;
      import com.google.maps.overlays.PolylineOptions;
      import com.google.maps.styles.StrokeStyle;
      import com.greensock.TweenMax;
      
      import flash.utils.setTimeout;
      
      import it.ht.rcs.console.entities.controller.EntityManager;
      import it.ht.rcs.console.entities.model.Entity;
      import it.ht.rcs.console.entities.model.Link;
      import it.ht.rcs.console.entities.model.Position;
      import it.ht.rcs.console.entities.model.Positions;
      import it.ht.rcs.console.entities.model.PositionsFlow;
      import it.ht.rcs.console.entities.view.components.advanced.timeline.HourRenderer;
      import it.ht.rcs.console.entities.view.map.CustomMarker;
      import it.ht.rcs.console.events.RefreshEvent;
      import it.ht.rcs.console.events.SectionEvent;
      import it.ht.rcs.console.monitor.controller.LicenseManager;
      import it.ht.rcs.console.search.model.SearchItem;
      import it.ht.rcs.console.target.model.Target;
      
      import locale.R;
      
      import mx.collections.ArrayCollection;
      import mx.core.FlexGlobals;
      import mx.rpc.events.FaultEvent;
      import mx.rpc.events.ResultEvent;

			//map stuff
			private var mapReady:Boolean;
			private var mapPane:IPane;
			private var centre:LatLng;
			private var icons:Dictionary; //pins?
			private var targetsMarkers:Dictionary; //pins?
			private var placesMarkers:Dictionary;
			private var overlays:Array;
			private var links:Array
			private var markers:Array;
			private var circles:Array;
			private var mapScale:Number;
			private var circleOverlay:IOverlay;
			private var bounds:LatLngBounds

			//Styling
			private var circleFillColor:uint=0xFF0000;
			private var circleFillAlpha:Number=0.2;
			private var circleBorderTickness:int=0.2;
			private var circleBorderFillColor:uint=0xFF0000;
			private var circleBorderFillAlpha:Number=0.5;

			private const ALPHA_RATIO:Number=100 / 60;
      
      
      [Bindable]
      public var actionbar:EntitiesActionBar

			[Bindable]
			public var section:EntitiesSection;
			[Bindable]
			public var entities:ArrayCollection; //all entities
			[Bindable]
			private var startDate:Date;
			[Bindable]
			private var endDate:Date;
			[Bindable]
			private var currentDate:Date;

			private var numEntitiesToShow:int;
			private var entitiesToShow:ArrayCollection //only targets and positions
			private var positions:ArrayCollection; //only positions
			private var targets:ArrayCollection; //only targets

      
      private function clearMap():void
      {
        if(map && overlays)
        {
        for (var i:int=0; i < overlays.length; i++)
        {
          map.removeOverlay(overlays[i] as IOverlay);
        }
        
        overlays=new Array()
        circles=new Array()
        map.clearOverlays()
        map.enabled=false;
        map.setZoom(1);
        map.setCenter(new LatLng(0, 0));
        }
      }
      
      
			private function drawMap():void
			{
				var i:int=0;
				var entity:Entity;
				targetsMarkers=new Dictionary()
				placesMarkers=new Dictionary()

				icons=new Dictionary()
				//remove all overlays and ckear map
				for (i=0; i < overlays.length; i++)
				{
					map.removeOverlay(overlays[i] as IOverlay);
				}
        overlays=new Array
        map.clearOverlays()
				map.setZoom(3);
				map.setCenter(new LatLng(0, 0));

				markers=new Array();
				circles=new Array();
				links=new Array()

				bounds=new LatLngBounds();

			/* 	if (positions.length > 0)
				{
					entity=positions.getItemAt(0) as Entity;
					centre=new LatLng(Number(entity.position.latitude), Number(entity.position.longitude));
					map.setCenter(centre, 14, MapType.NORMAL_MAP_TYPE);
					overlays=new Array();
				} */

				var coordinates:LatLng
				var customMarker:CustomMarker
				var marker:Marker;
				var fillColor:uint;
				var circleBounds:LatLngBounds;

				//positions
				for (i=0; i < positions.length; i++)
				{
					entity=positions.getItemAt(i) as Entity;
					coordinates=new LatLng(Number(entity.position.latitude), Number(entity.position.longitude));
					customMarker=new CustomMarker(entity)
					marker=new Marker(coordinates, new MarkerOptions({icon: customMarker, hasShadow: false}));
					icons[marker]=customMarker;
					//marker.shadow.visible=true;
					marker.addEventListener(MapMouseEvent.CLICK, onMarkerClick);
					marker.addEventListener(MapMouseEvent.DOUBLE_CLICK, onMarkerDoubleClick)
					marker.foreground.alpha=1;
					bounds.extend(coordinates);
					fillColor=entity.type == "position" ? 0x0000FF : 0xFF0000;
					//circleBounds=drawCircle(Number(entity.position_attr.accuracy) / 1000, coordinates, fillColor);
					//bounds.union(circleBounds)
					overlays.push(marker);
					markers.push(marker);
					map.addOverlay(marker);

					placesMarkers[entity._id]=marker
          marker.foreground.visible=false

				}
				//targets
				for (i=0; i < targets.length; i++)
				{
					entity=targets.getItemAt(i) as Entity;
					if (entity.position)
					{
						coordinates=new LatLng(Number(entity.position.latitude), Number(entity.position.longitude)); //last position!!!
						customMarker=new CustomMarker(entity)
						marker=new Marker(coordinates, new MarkerOptions({icon: customMarker, hasShadow: false}));
						icons[marker]=customMarker;
						//marker.shadow.visible=true;
						marker.addEventListener(MapMouseEvent.CLICK, onMarkerClick);
						marker.addEventListener(MapMouseEvent.DOUBLE_CLICK, onMarkerDoubleClick)
						marker.foreground.alpha=1;
						bounds.extend(coordinates);
						fillColor=entity.type == "position" ? 0x0000FF : 0xFF0000;
						//circleBounds=drawCircle(Number(entity.position_attr.accuracy) / 1000, coordinates, fillColor);
						//bounds.union(circleBounds)
						overlays.push(marker);
						markers.push(marker);
						map.addOverlay(marker);
						targetsMarkers[entity._id]=marker
            marker.foreground.visible=false
					}
        
						
				}
        if(!map.enabled)
          map.enabled=true;
				map.setCenter(bounds.getCenter(), map.getBoundsZoomLevel(bounds));
			}
      
      private function onRemovedFromStage():void
      {
      tracker.doStop()
      }
      
      public function doStop():void
      {
        tracker.doStop()
      }
      

			private function drawCircle(radiusKm:Number, position:LatLng, color:uint):LatLngBounds
			{
				if (isNaN(radiusKm) || radiusKm <= 0)
				{
					//return new LatLngBounds();
					radiusKm=0.02
				}

				mapScale=calculateMapScale();
				var shape:Shape=new Shape();
				var overlay:GroundOverlay;
				var bounds:LatLngBounds;
				var centrePoint:Point;
				var topLeft:LatLng;
				var bottomRight:LatLng;
				var options:GroundOverlayOptions;
				var circleWidth:Number=radiusKm * 2 * mapScale;

				shape.graphics.lineStyle(circleBorderTickness, color, circleBorderFillAlpha);
				shape.graphics.beginFill(color, circleFillAlpha);
				shape.graphics.drawCircle(circleWidth * .5, circleWidth * .5, circleWidth);
				shape.graphics.endFill();
				centrePoint=mapPane.fromLatLngToPaneCoords(position);
				topLeft=mapPane.fromPaneCoordsToLatLng(new Point(centrePoint.x - circleWidth * .5, centrePoint.y - circleWidth * .5));
				bottomRight=mapPane.fromPaneCoordsToLatLng(new Point(centrePoint.x + circleWidth * .5, centrePoint.y + circleWidth * .5));
				bounds=new LatLngBounds(topLeft, bottomRight);
				options=new GroundOverlayOptions();
				options.applyProjection=true;
				circleOverlay=new GroundOverlay(shape, bounds, options);
				map.addOverlay(circleOverlay);
				overlays.push(circleOverlay);
				circles.push(circleOverlay);

				return bounds
			}



			private function zoomToBounds():void
			{
				bounds=new LatLngBounds
				var i:int
				var entity:Entity;
				var coordinates:LatLng
				var marker:Marker
        
				if (positionsCh.selected)
				{
          //targets
          for (var p:* in placesMarkers)
          {
            marker=placesMarkers[p] as Marker;
            if (marker.foreground.visible)
            {
              coordinates=marker.getLatLng()
              bounds.extend(coordinates);
            }
          }
				}
				//targets
				for (var m:* in targetsMarkers)
				{
					marker=targetsMarkers[m] as Marker;
					if (marker.foreground.visible)
					{
						coordinates=marker.getLatLng()
						bounds.extend(coordinates);
					}
				}
				map.setCenter(bounds.getCenter(), map.getBoundsZoomLevel(bounds));
        map.setZoom(map.getBoundsZoomLevel(bounds)-1)
			}

			private function calculateMapScale():Number
			{
				var topLeft:LatLng;
				var bottomLeft:LatLng;
				var scale:Number;
				var distance:Number;

				topLeft=mapPane.fromPaneCoordsToLatLng(new Point(0, 0));
				bottomLeft=mapPane.fromPaneCoordsToLatLng(new Point(0, map.height));
				distance=topLeft.distanceFrom(bottomLeft) / 1000;
				scale=map.height / distance;

				return scale;
			}

			public function init():void
			{
				map.addEventListener(MapEvent.MAP_READY, onMapReady)
				FlexGlobals.topLevelApplication.addEventListener(RefreshEvent.REFRESH, onRefresh);

				//temporary dates
				startDate=new Date();
				startDate.minutes=0
				startDate.seconds=0

				startDate.time=startDate.time - (1000 * 60 * 60 * 24 * 30); //60 days
				endDate=new Date();
				endDate.minutes=0
				endDate.seconds=0;
        
        fitCh.selected=true;
        positionsCh.selected=false;
        linksCh.selected=false;

				if (fromDf)
					fromDf.selectedDate=startDate;
				if (toDf)
					toDf.selectedDate=endDate;
        tracker.visible=false;
        loadingBox.visible=true;
        setTimeout(tracker.init, 100)

			}

			private function onDateFilter():void
			{
				startDate=fromDf.selectedDate;
				startDate.minutes=0;
				startDate.seconds=0;

				endDate=toDf.selectedDate;
				endDate.minutes=0;
				endDate.seconds=0;
				//TODO CHECK DATES CONSISTENCY
				//("start date: " + startDate);
				//trace("end date: " + endDate);
        tracker.visible=false;
        loadingBox.visible=true;
        clearMap()
        setTimeout(tracker.draw, 100)
        

			}
      
      private function onTrackerReady():void
      {
        //tracker.visible=true;
        //loadingBox.visible=false;
        clearMap()
        refresh()
      }

			private function onAddedToStage():void
			{
        trace("GEO MAP ADDED TO STAGE")
        /* if(this.initialized)
        {
          tracker.visible=false;
          loadingBox.visible=true;
          fitCh.selected=false;
          positionsCh.selected=true;
          linksCh.selected=true;
          clearMap()
  				refresh()
        } */
        //reset??
			}


			private function onRefresh(e:RefreshEvent):void
			{
        clearMap()
				refresh();

			}
      
      //TEMPORARY!!!!!
      private function isIn(a:ArrayCollection, e:Entity):Boolean
      {
        for(var i:int=0;i<a.length;i++)
        {
        var entity:Entity=a.getItemAt(i) as Entity;
        if(entity._id==e._id)
          return true;
        
        }
        return false;
      }

			private function onDetailResult(e:ResultEvent):void
			{
				numEntitiesToShow--
				var entity:Entity=e.result as Entity

				if (entity.type == "position")
				{
					if(!isIn(positions, entity))
          {
            positions.addItem(entity)
            trace("adding a position: "+entity._id)
          }
            
				}
        else if (entity.type == "target")
				{
          if(!isIn(targets, entity))
          {
            targets.addItem(entity)
          }
				}
				if (numEntitiesToShow == 0)
				{
					trace("ALL ENTITIES DETAILS LOADED")
					trace("GET TARGETS POSITIONS")
          
					getPositionsSummary(targets)
				
				}
			}

			private function refresh():void
			{
				trace("REFRESH")
				trace("TOTAL ENTITIES: " + entities.length)

				//get details about entities
				info.selectedItem=null;
				info.selectedItems=null;

				entitiesToShow=new ArrayCollection()
				numEntitiesToShow=0;

				var entity:Entity;
				var i:int;
				for (i=0; i < entities.length; i++)
				{
					entity=entities.getItemAt(i) as Entity;
					if (entity.type == "position" || entity.type == "target")
						entitiesToShow.addItem(entity);
				}

				numEntitiesToShow=entitiesToShow.length;

				positions=new ArrayCollection()
				targets=new ArrayCollection()

				for (i=0; i < entitiesToShow.length; i++)
				{
					EntityManager.instance.show(entitiesToShow.getItemAt(i)._id, onDetailResult)
				}


			}

			private function onMapReady(e:MapEvent):void
			{
				trace("GOOGLE MAP IS READY")
				mapReady=true;
				map.removeEventListener(MapEvent.MAP_READY, onMapReady)
				map.addControl(new ZoomControl());
				map.addControl(new PositionControl());
				map.addControl(new MapTypeControl());
				map.addEventListener(MapMouseEvent.CLICK, onMapClick);
				mapPane=map.getPaneManager().getPaneAt(PaneId.PANE_MAP);
				overlays=new Array();
			}

			private function onMapClick(e:MapMouseEvent):void
			{
				trace("map clicked");
        unselectAll();
				e.stopImmediatePropagation()
			  
			}

			private function getPositionsSummary(targets:ArrayCollection):void
			{
				var ids:Array=new Array();
				for (var i:int=0; i < targets.length; i++)
				{
					var e:Entity=targets.getItemAt(i) as Entity;
					ids.push(e._id)
				}
				EntityManager.instance.positions(ids, formatDate(startDate), formatDate(endDate), true, onPositionsSummaryResult, onPositionsFault)
			}

			private function getPositionsDetail(targets:ArrayCollection):void
			{
				var ids:Array=new Array();
				for (var i:int=0; i < targets.length; i++)
				{
					var e:Entity=targets.getItemAt(i) as Entity;
					ids.push(e._id)
				}
				EntityManager.instance.positions(ids, formatDate(startDate), formatDate(endDate), false, onPositionsDetailResult, onPositionsFault)
			}

			private function onPositionsDetailResult(e:ResultEvent):void
			{
				var pos:ArrayCollection=e.result as ArrayCollection;
				for (var i:int=0; i < pos.length; i++)
				{
					var d:Date=new Date()
					d.time=pos.getItemAt(i).time * 1000;
					trace(d)
				}

				tracker.populateMinutes(pos)
        tracker.visible=true;
        loadingBox.visible=false;
        
				drawMap()
			}

			private function onPositionsSummaryResult(e:ResultEvent):void
			{
				var pos:ArrayCollection=e.result as ArrayCollection;
				for (var i:int=0; i < pos.length; i++)
				{
					var d:Date=new Date()
					d.time=pos.getItemAt(i).time * 1000;
					trace(d)
				}
				tracker.populate(pos)
        getPositionsDetail(targets)
      
			}

			private function onPositionsFault(e:FaultEvent):void
			{
				trace("positions fault")
			}

			//Entities operations
			private function onEntityDeleted():void
			{
				//TODO
			}

			private function onEntityCreated():void
			{
				//TODO
			}

			private function onEntityUpdated():void
			{
				//TODO
			}

			private function onLinkAdded():void
			{
				//TODO
			}

			private function onMarkerClick(e:MapMouseEvent):void
			{

				e.stopImmediatePropagation()
				var icon:CustomMarker
				var i:*;
				//var customMarker:CustomMarker=e.currentTarget.wrapper.options.icon as CustomMarker;
				if (e.ctrlKey) //multiple selection
				{
					icon=icons[e.currentTarget];
					icon.selected=!icon.selected;
					var selectedItems:Vector.<Object>=new <Object>[];
          
					for (i in icons)
					{
						icon=icons[i]
						if (icon.selected)
							selectedItems.push(icon.entity);
					}
					info.selectedItems=selectedItems;
          actionbar.selectedObjects=selectedItems;
					if (selectedItems.length > 0)
          {
						info.selectedItem=selectedItems[selectedItems.length - 1]
            actionbar.selectedObject=selectedItems[selectedItems.length - 1]
          }
					else
          {
						info.selectedItem=null
            actionbar.selectedObject=null
          }
				}

				else //single selection
				{
					for (i in icons)
					{
						icon=icons[i]
						icon.selected=false;
					}
					icon=icons[e.currentTarget];
					icon.selected=!icon.selected;
					info.selectedItem=icon.selected ? icon.entity : null;
					info.selectedItems=new <Object>[info.selectedItem];
          
          actionbar.selectedObject=icon.selected ? icon.entity : null;
          actionbar.selectedObjects=new <Object>[info.selectedItem];
          actionbar.selectedObjects.push(info.selectedItem)
				}

			}
      
      public function unselectAll():void
      {
        var icon:CustomMarker
        for (var i:* in icons)
        {
          icon=icons[i]
          icon.selected=false;
        }
        info.selectedItem=null
        info.selectedItems=null
        
        actionbar.selectedObject=null
        actionbar.selectedObjects=null
      }

			private function onMarkerDoubleClick(e:MapMouseEvent):void
			{
				e.stopImmediatePropagation();
				var icon:CustomMarker;
				icon=icons[e.currentTarget];
				var event:SectionEvent=new SectionEvent(SectionEvent.CHANGE_SECTION);
				event.section=SectionEvent.INTELLIGENCE;
				event.subsection='entity';
				event.item=new SearchItem(icon.entity) //SearchManager.instance.getItem(icon.entity._id);
				FlexGlobals.topLevelApplication.dispatchEvent(event);

			}

			private function onDateChange():void
			{
        
				var i:int;
				//remove links
				//draw links
				if (links)
				{
					for (i=0; i < links.length; i++)
					{
						map.removeOverlay(links[i] as IOverlay);

					}
				}
				links=new Array()

				trace("Geo Map > Date Change: " + tracker.currentDate)
				currentDate=tracker.currentDate;

				
			
        
				var marker:Marker
				for (var tm:* in targetsMarkers)
				{
					marker=targetsMarkers[tm] as Marker;
          marker.foreground.visible=false;
				}

				for (var pm:* in placesMarkers)
				{
					marker=placesMarkers[pm] as Marker;
					if (positionsCh.selected)
          {
						marker.foreground.visible=true;
          }
					else
          {
            marker.foreground.visible=false;
          }
				}
				//
				var key:String=String(currentDate.minutes)
          
        var h:HourRenderer=tracker.currentItem;
        if (!h)
          return;
       // trace("num positions: " + h.positions.length)
        if(h.minutes[key]==null) return;

				for (i=0; i < h.minutes[key].length; i++)
				{
					var log:Positions=h.minutes[key].getItemAt(i) as Positions;
					/*  for (i=0; i < h.positions.length; i++)
					 { */
					//var log:Positions=h.positions.getItemAt(i) as Positions;
					var entity:Entity=getTarget(log._id);

					var p:Position=log.position;
				/* 	trace("name: " + entity.name)
					trace("lat: " + p.lat)
					trace("long: " + p.lon)
					trace("rad: " + p.rad)
					trace("alpha: " + log.alpha)
					trace("================") */

					marker=targetsMarkers[entity._id] as Marker;
          marker.foreground.visible=true;
					marker.setLatLng(new LatLng(p.lat, p.lon))

					marker.foreground.alpha=(log.alpha * ALPHA_RATIO) / 100;


					//marker.getLatLng().
					//draw links
					if (entity.links && linksCh.selected)
					{
						//draw connections
						for (var l:int=0; l < entity.links.length; l++)
						{
							var link:Link=entity.links.getItemAt(l) as Link;
							var entity2:Entity=EntityManager.instance.getItem(link.le);
							// trace("Link beetween: "+entity.type+ " and "+EntityManager.instance.getEntityById(link.le).type)
							if (entity && entity2)
							{
								if (entity.type == "target" && entity2.type == "position")
								{
									var color:uint=0xFF0000 //relevanceColors[link.rel]
									drawLink(marker.getLatLng(), new LatLng(Number(entity2.position.latitude), Number(entity2.position.longitude)), color);
								}
							}
						}
					}
				}
				if (fitCh.selected)
					zoomToBounds();
			}

			private function drawLink(pos1:LatLng, pos2:LatLng, color:uint):void
			{
				//https://developers.google.com/maps/documentation/flash/overlays
				var polyline:Polyline=new Polyline([pos1, pos2], new PolylineOptions({strokeStyle: new StrokeStyle({color: color, thickness: 0.5, alpha: 1})}));
				map.addOverlay(polyline);
				overlays.push(polyline);
				links.push(polyline)

			}

			private function getTarget(id:String):Entity
			{
				if (!targets)
					return null
				for (var i:int=0; i < targets.length; i++)
				{
					var entity:Entity=targets.getItemAt(i) as Entity;
					if (entity._id == id)
						return entity;
				}
				return null;
			}

			//utils stuff
			private function formatDate(d:Date):String
			{
				return String(int(d.time / 1000));
			}

			private function doubleDigits(n:Number):String
			{
				if (n < 10)
					return "0" + String(n);
				return String(n);
			}
		]]>
	</fx:Script>
	<!--<entities:GeoMapActionBar section="{section}"
														selectedObject="{info.selectedItem}"
														selectedObjects="{info.selectedItems}"
														entityDeleted="onEntityDeleted()"
														entityCreated="onEntityCreated()"
														entityUpdated="onEntityUpdated()"
														linkAdded="onLinkAdded()"/>-->
	<s:HGroup width="100%"
						height="100%"
						gap="5">

		<s:VGroup width="100%"
							height="100%">
			<s:HGroup verticalAlign="middle"
								horizontalAlign="left"
								width="100%"
								paddingTop="6">
				<s:CheckBox id="fitCh"
										label="Fit bounds"
										change="onDateChange()"
                    selected="true"/>
				<s:Spacer width="8"/>
				<s:CheckBox id="positionsCh"
										label="Show places"
										selected="false"
										change="onDateChange(); unselectAll()"/>
				<s:Spacer width="8"/>
				<s:CheckBox id="linksCh"
										label="Draw links"
										selected="false"
										change="onDateChange()"/>
				<s:Spacer width="8"/>
				<s:Spacer width="100%"/>
				<s:Label text="{R.get('FILTER_DATA')} "
								 fontWeight="bold"/>
				<s:Label text="{R.get('FROM')}:"
								 fontWeight="bold"/>


				<mx:DateField id="fromDf"
											formatString="YYYY-MM-DD"
											selectedDate="{startDate}"
											change="onDateFilter()"/>

				<s:Label text="{R.get('TO')}:"
								 fontWeight="bold"/>
				<mx:DateField id="toDf"
											formatString="YYYY-MM-DD"
											selectedDate="{endDate}"
											change="onDateFilter()"/>

			</s:HGroup>
			<s:Line width="100%">
				<s:stroke>
					<s:SolidColorStroke color="0xCCCCCC"/>
				</s:stroke>
			</s:Line>
			<s:BorderContainer width="100%"
												 height="100%"
												 borderAlpha="1"
												 borderColor="0xCCCCCC"
												 backgroundColor="0xCCCCCC"
												 backgroundAlpha="0.1">
				<maps:Map xmlns:maps="com.google.maps.*"
									id="map"
									width="100%"
									height="100%"
									key="ABQIAAAA8fmTpYQsyimBWFWKgeE9PBRhMg83CBLwD9y4vh6Mu8HzQS3H_RRayLm54B1SF17x6N9sYwYVwJV_FQ"
									url="http://www.hackingteam.it/"
									sensor="false"
									accessibilityDescription=""
									enabled="{LicenseManager.instance.correlation}"
									mapevent_mapready="onMapReady(event)"/>
			</s:BorderContainer>
			<s:Line width="100%">
				<s:stroke>
					<s:SolidColorStroke color="0xCCCCCC"/>
				</s:stroke>
			</s:Line>
			<s:Group width="100%"
							 >
				<timeline:Tracker width="100%"
													startDate="{startDate}"
													endDate="{endDate}"
													dateChange="onDateChange()" ready="onTrackerReady()"
													id="tracker"/>
				<s:HGroup verticalAlign="middle"
									horizontalAlign="center"
									id="loadingBox"
									visible="true"
									width="100%"
									height="100%">
					<s:SWFLoader source="@Embed('/img/evidence/spinner16.swf')"/>
					<s:Label text="Loading timeline data. Please wait..."
									 fontWeight="bold"/>
				</s:HGroup>
			</s:Group>
		</s:VGroup>

		<entities:EntityInfoPanel id="info"/>
	</s:HGroup>

</s:VGroup>
